<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Distributed Processing: Bipartite Optimizations and POLE - /home/mackle/emporium</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Now we're cooking with gas"><script type=text/javascript src=https://unpkg.com/vis-network/standalone/umd/vis-network.min.js></script><script type=text/javascript src=https://unpkg.com/vis-network/standalone/umd/vis-network.min.js></script><meta property="og:image" content><meta property="og:url" content="https://mackle.io/posts/distributed-processing-bipartite-optimizaitons-and-pole/"><meta property="og:site_name" content="/home/mackle/emporium"><meta property="og:title" content="Distributed Processing: Bipartite Optimizations and POLE"><meta property="og:description" content="Now we're cooking with gas"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-25T19:59:58+00:00"><meta property="article:modified_time" content="2021-03-25T19:59:58+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distributed Processing: Bipartite Optimizations and POLE"><meta name=twitter:description content="Now we're cooking with gas"><link href=https://mackle.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://mackle.io/css/main.fc35b62150b44d2f47a37091c32f656655779aff4a4673741b643c709862b602.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://mackle.io/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://mackle.io/>/home/mackle/emporium</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Distributed Processing: Bipartite Optimizations and POLE</h1><div class=meta>Posted on Mar 25, 2021</div></div><section class=body><h1 id=introduction>Introduction</h1><p>On the first post on graph colouring I touched on bipartite graphs and how we can efficiently colour them with only two colours. This will underpin one of the optimizations we can make on the solution, which currently is only an implementation of the greedy algorithm.</p><p>If you haven&rsquo;t read the first part I&rsquo;d recommend doing so <a href=/posts/distributed-processing-graph-colouring/>here</a>.</p><h1 id=bipartite-graphs>Bipartite Graphs</h1><p><a href=https://en.wikipedia.org/wiki/Bipartite_graph>Bipartite graphs</a> are a subset of graphs where all vertices can be split into one of two subgraphs such that no two vertices in the same subgraph share an edge. If we want to colour a bipartite graph, we can just assign one colour to each of these subgraphs as, by definition, they will contain no adjacent entities.</p><p>An example of a bipartite graph is a wheel graph:</p><figure><div id=wheel class=graph></div><figcaption></figcaption></figure><script type=text/javascript>var options,network,container=document.getElementById("wheel"),nodes=new vis.DataSet([{id:1,label:"A",color:{border:"red"}},{id:2,label:"B",color:{border:"blue"}},{id:3,label:"C",color:{border:"blue"}},{id:4,label:"D",color:{border:"blue"}},{id:5,label:"E",color:{border:"blue"}},{id:6,label:"F",color:{border:"red"}},{id:7,label:"G",color:{border:"red"}},{id:8,label:"H",color:{border:"red"}},{id:9,label:"I",color:{border:"red"}}]),edges=new vis.DataSet([{from:1,to:2,color:"black"},{from:1,to:3,color:"black"},{from:1,to:4,color:"black"},{from:1,to:5,color:"black"},{from:3,to:6,color:"black"},{from:4,to:7,color:"black"},{from:5,to:8,color:"black"},{from:2,to:9,color:"black"}]),data={nodes,edges};window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches||document.querySelector("meta[name=darkmode]")!==null&&document.querySelector("meta[name=darkmode]").content==="true"?(options={nodes:{color:{border:"#FFFFFF",background:"#202124",highlight:{border:"#50fa7b",background:"#202124"}},font:{color:"#FFFFFF"}},interaction:{multiselect:!0}}):(options={nodes:{color:{border:"#232333",background:"#FFFFFF",highlight:{border:"#FF0000",background:"#FFFFFF"}}},interaction:{multiselect:!0}}),network=new vis.Network(container,data,options)</script><p>In this example, we alternate which colour we assign as we traverse the graph outwards. If we assign the centre vertex the colour red, then the first vertexes on each spoke are blue, then back to red for the second and so on. The two subgraphs which form the bipartite graph are the same two sets of vertices which are coloured blue and red.</p><h1 id=pole-model>POLE Model</h1><p>When I was first thinking about the problem defined in the first blog posts, the first application that came to mind was a Person, Object, Location, Event (POLE) model.</p><p>POLE Models are a common type of data model used in fraud & other investigative use cases. The main properties of a POLE model are as follows:</p><ul><li>the person, object, location entities are not directly linked, instead are linked through event entities,</li><li>events can be linked to other events,</li><li>analysis records are linked by a one-many relationship from a POLE entity.</li></ul><p>A very basic pole model could be something like:</p><figure><div id=pole class=graph></div><figcaption></figcaption></figure><script type=text/javascript>var options,network,container=document.getElementById("pole"),nodes=new vis.DataSet([{id:1,label:"Person"},{id:2,label:"Object"},{id:3,label:"Location"},{id:4,label:"Event One"},{id:5,label:"Event Two"},{id:6,label:"Event Three"},{id:7,label:"Person Analysis"}]),edges=new vis.DataSet([{from:1,to:4},{from:1,to:5},{from:1,to:6},{from:2,to:5},{from:2,to:6},{from:3,to:4},{from:3,to:6},{from:1,to:7},{from:5,to:6}]),data={nodes,edges};window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches||document.querySelector("meta[name=darkmode]")!==null&&document.querySelector("meta[name=darkmode]").content==="true"?(options={nodes:{color:{border:"#FFFFFF",background:"#202124",highlight:{border:"#50fa7b",background:"#202124"}},font:{color:"#FFFFFF"}},interaction:{multiselect:!0}}):(options={nodes:{color:{border:"#232333",background:"#FFFFFF",highlight:{border:"#FF0000",background:"#FFFFFF"}}},interaction:{multiselect:!0}}),network=new vis.Network(container,data,options)</script><p>If we consider only person, object and location entities first, we can see that these can never be adjacent as they must link through event entities (at least in the purest applications of the data model). This sounds like a pretty good candidate to start optimizing our model.</p><h1 id=passing-insight-to-our-algorithm>Passing insight to our algorithm</h1><p>The greedy algorithm does yield good results, but like any other dilligent, locally optimized algorithm it fails to see the bigger picture.</p><p>Using our algorithm we will not reliably identify any graph-wide patterns, as the algorithm only assigns colours to a node based on it&rsquo;s adjacent nodes. If we have a &ldquo;global insight&rdquo;, e.g. spot a large group of entities that can be coloured the same colour, how can we pass this knowledge onto our algorithm?</p><p>We simply pre-assign the colours - effectively making the choice for the algorithm.</p><p>To implement this we only have to initialize the initial colour mappings and pass this to our greedy algorithm. The amended code is as follows (ellipses show removed code for brevity),</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>colour</span>(graph, order, colours<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>  <span style=color:#75715e># Cannot modify an arguments default value in python as it is mutable</span>
</span></span><span style=display:flex><span>  colours <span style=color:#f92672>=</span> colours <span style=color:#f92672>or</span> {}
</span></span><span style=display:flex><span>  max_colour <span style=color:#f92672>=</span> max(colours<span style=color:#f92672>.</span>values()) 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> order:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the colours of the neighbours</span>
</span></span><span style=display:flex><span>    used_colours <span style=color:#f92672>=</span> set(
</span></span><span style=display:flex><span>        [colours[neighbour] <span style=color:#66d9ef>for</span> neighbour <span style=color:#f92672>in</span> graph[vertex] <span style=color:#66d9ef>if</span> neighbour <span style=color:#f92672>in</span> colours]
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    colour <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> used_colour <span style=color:#f92672>in</span> used_colours:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Find the first available colour that hasn&#39;t been used</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> colour <span style=color:#f92672>!=</span> used_colour:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        colour <span style=color:#f92672>=</span> colour <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> colour <span style=color:#f92672>&gt;</span> max_colour:
</span></span><span style=display:flex><span>            max_colour <span style=color:#f92672>=</span> colour
</span></span><span style=display:flex><span>    colours[vertex] <span style=color:#f92672>=</span> colour
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> colours, max_colour
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>colours <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;Person&#39;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;Object&#39;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;Location&#39;</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># We only need to assign colours to vertices that don&#39;t have pre-assigned colours</span>
</span></span><span style=display:flex><span>blank_vertices <span style=color:#f92672>=</span> [vertex <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> vertices where vertex <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> colours]
</span></span><span style=display:flex><span>vertex_colours, max_colour <span style=color:#f92672>=</span> colour(graph, blank_vertices, colours)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span> </span></span></code></pre></div><h1 id=results>Results</h1><p>Let&rsquo;s base line against a randomly generated POLE data model with 17500 entities and 130000 relationships (this is orders of magnitude larger than most data models).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Chromatic number: 10</span></span></code></pre></div><p>We can provide the following insights to our algorithm:</p><ul><li>process person, object and location entities concurrently first</li><li>process event entities which are not linked to other event entities second</li><li>process analysis entities alongside event entities.</li></ul><p>Suppose we have functions (<em>is_pol, is_analysis, is_event</em>) that tell us if a given vertex is a POL, Event or analysis entity we can then pre-ssign colours as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>has_event_neighbours</span>(graph, vertex):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len([neighbour <span style=color:#66d9ef>for</span> neighbour <span style=color:#f92672>in</span> graph[vertex] <span style=color:#66d9ef>if</span> is_event(neighbour)]) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> graph<span style=color:#f92672>.</span>keys():
</span></span><span style=display:flex><span>    <span style=color:#75715e># If POL process first</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_pol(vertex):
</span></span><span style=display:flex><span>        colours[vertex] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If analysis process second</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_analysis(vertex):
</span></span><span style=display:flex><span>        colours[vertex] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If event and no other event_event relationships process second</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> is_event(vertex) <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> has_event_neighbours(graph, vertex): 
</span></span><span style=display:flex><span>        colours[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span></span></span></code></pre></div><p>If we re-run our algorithm we see a large improvement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Chromatic number: 5</span></span></code></pre></div><p>We have reduced the number of colours by half!</p><p>Pre-colouring our graph also has a performance benefit. We have limited the number of vertices which need to be visited, and therefore our algorithm will take less time to complete. Over 1000 iterations this difference is very significant:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Chromatic number: 10, Time to process: 27.858741760253906
</span></span><span style=display:flex><span>Optimized Chromatic Number: 5, Time to process: 15.56061840057373</span></span></code></pre></div><p>This means in the same amount of time, we can also test ~2x as many random sequences of vertices, improving our chance of finding an optimal, or close to, solution.</p><h1 id=other-benefits>Other benefits</h1><p>More efficient colourings and performance improvements aren&rsquo;t the only benefits of pre-colouring the graph. If we wish to prioritize some entities being processed earlier we can also do this by pre-colouring these entities. We may however see a performance degradation because of this as the resulting colouring may be suboptimal.</p><p>We can also dictate some entities not be processed together as well. For example, if we have multiple data sources providing our entities then we may not want to process too many entities from the same data source at the same time. To do this we can add suplimentary relationships between these entities, thereby making them adjacent and enforcing they will not be processed together.</p><h1 id=conclusion>Conclusion</h1><p>For the original problem domain, this is a &ldquo;good enough&rdquo; solution. Having a 50% decrease in the number of iterations versus a greedy colouring was an excellent improvement and highlights the importance of domain knowledge in solving technical problems.</p><p>There are still a few remaining caveats which intrigue me however, namely that we current process all relationships and that all entities are assumed to take an equal time to process. This however does move away from graph colouring and into optimization of weighted graphs. I may have to dust off a few textbooks&mldr;</p></section><div class=post-tags></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/mackles rel=me title=Github><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://www.linkedin.com/in/stuart-mackle-5b2055105/ rel=me title=LinkedIn><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#linkedin"/></svg></a><a class=border></a></div><div class=footer-info>2025 © Stuart Mackle | <a href=https://github.com/mackles/archie-network>Archie Network Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>