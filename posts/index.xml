<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on /home/mackle/emporium</title><link>https://mackle.io/posts/</link><description>Recent content in Posts on /home/mackle/emporium</description><generator>Hugo</generator><language>en-us</language><copyright>Â© Stuart Mackle</copyright><lastBuildDate>Tue, 22 Jul 2025 12:44:37 -0700</lastBuildDate><atom:link href="https://mackle.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Quacking Performance: DuckDB</title><link>https://mackle.io/posts/quacking-performance-duckdb/</link><pubDate>Tue, 22 Jul 2025 12:44:37 -0700</pubDate><guid>https://mackle.io/posts/quacking-performance-duckdb/</guid><description>&lt;h1 id="intro-duck-tion">Intro-duck-tion&lt;/h1>
&lt;p>If you&amp;rsquo;ve not came across DuckDB previously I&amp;rsquo;d highly recommend looking into it, it&amp;rsquo;s fast, open source and rapidly gaining traction within the Data &amp;amp; Analytics space. DuckDB is designed for fast SQL queries on analytical workloads, namely it&amp;rsquo;s design choices favour aggregation and grouping, particularly in instances where only a subset of columns are used. This greatly reduces memory usage and runtime in applicable instances.&lt;/p>
&lt;h1 id="warehouse-storage-rows-vs-columns">Warehouse Storage: Rows vs Columns&lt;/h1>
&lt;p>To highlight the differences between row-based and column-based data stores, I&amp;rsquo;ll use the analogy that we&amp;rsquo;re a grocery store storing customer orders.&lt;/p></description></item><item><title>Distributed Processing: Bipartite Optimizations and POLE</title><link>https://mackle.io/posts/distributed-processing-bipartite-optimizaitons-and-pole/</link><pubDate>Thu, 25 Mar 2021 19:59:58 +0000</pubDate><guid>https://mackle.io/posts/distributed-processing-bipartite-optimizaitons-and-pole/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>On the first post on graph colouring I touched on bipartite graphs and how we can efficiently colour them with only two colours. This will underpin one of the optimizations we can make on the solution, which currently is only an implementation of the greedy algorithm.&lt;/p>
&lt;p>If you haven&amp;rsquo;t read the first part I&amp;rsquo;d recommend doing so &lt;a href="https://mackle.io/posts/distributed-processing-graph-colouring/">here&lt;/a>.&lt;/p>
&lt;h1 id="bipartite-graphs">Bipartite Graphs&lt;/h1>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Bipartite_graph">Bipartite graphs&lt;/a> are a subset of graphs where all vertices can be split into one of two subgraphs such that no two vertices in the same subgraph share an edge. If we want to colour a bipartite graph, we can just assign one colour to each of these subgraphs as, by definition, they will contain no adjacent entities.&lt;/p></description></item><item><title>Distributed Processing: Graph Colouring</title><link>https://mackle.io/posts/distributed-processing-graph-colouring/</link><pubDate>Sun, 21 Feb 2021 02:57:19 +0000</pubDate><guid>https://mackle.io/posts/distributed-processing-graph-colouring/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>Last year I was presented with a rather interesting issue which gave me an opportunity to use some latent mathematics knowledge. This post covers the simplest form of the problem where some of the complexity is removed via constraints. The problem revolves around efficiently processing a data model definiton and can be summarised as follows:&lt;/p>
&lt;p>&lt;em>Given an entity-relationship(ER) model with only many-to-many relationships and multiple isolated workers, with each worker having the following properties:&lt;/em>&lt;br>
&lt;em>- it can only process a single entity and the associated relationships concurrently&lt;/em>&lt;br>
&lt;em>- it will fail if it processes a relationship at the same time as another worker&lt;/em>&lt;br>
&lt;em>- each entity and its set of relationships take the same time to process.&lt;/em>&lt;/p></description></item></channel></rss>