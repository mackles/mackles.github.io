<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Distributed Processing: Graph Colouring - /home/mackle/emporium</title><meta name=viewport content="width=device-width,initial-scale=1"><script type=text/javascript src=https://unpkg.com/vis-network/standalone/umd/vis-network.min.js></script><meta property="og:image" content><meta property="og:title" content="Distributed Processing: Graph Colouring"><meta property="og:description" content="A detour from data indexing into mathematics"><meta property="og:type" content="article"><meta property="og:url" content="https://mackle.io/posts/distributed-processing-graph-colouring/"><meta property="article:published_time" content="2021-02-21T02:57:19+00:00"><meta property="article:modified_time" content="2021-02-21T02:57:19+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Distributed Processing: Graph Colouring"><meta name=twitter:description content="A detour from data indexing into mathematics"><script src=https://mackle.io/js/feather.min.js></script><link href=https://mackle.io/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://mackle.io/css/main.css><link rel=stylesheet type=text/css href=https://mackle.io/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://mackle.io/>/home/mackle/emporium</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a></nav></header><main><article><div class=title><h1 class=title>Distributed Processing: Graph Colouring</h1><div class=meta>Posted on Feb 21, 2021</div></div><section class=body><h1 id=introduction>Introduction</h1><p>Last year I was presented with a rather interesting issue which gave me an opportunity to use some latent mathematics knowledge. This post covers the simplest form of the problem where some of the complexity is removed via constraints. The problem revolves around efficiently processing a data model definiton and can be summarised as follows:</p><p><em>Given an entity-relationship(ER) model with only many-to-many relationships and multiple isolated workers, with each worker having the following properties:</em><br><em>- it can only process a single entity and the associated relationships concurrently</em><br><em>- it will fail if it processes a relationship at the same time as another worker</em><br><em>- each entity and its set of relationships take the same time to process.</em></p><p><em>How many workers do we start and what entities does each worker process?</em></p><p>This problem is a perfect example of why I love maths and computer science - what is a complex distributed processing problem constrained by software limitations can be distilled down to a simple problem a non-technical individual can understand.</p><h1 id=simple-example>Simple Example</h1><p>Consider this simple example of an entity-relationship model, how would we distribute these entities to multiple workers?</p><figure><div id=basic class=graph></div><figcaption>Tip: Select any of the entities and the diagram will highlight which relationships are also processed.</figcaption></figure><script type=text/javascript>var container=document.getElementById('basic');var nodes=new vis.DataSet([{id:1,label:'A'},{id:2,label:'B'},{id:3,label:'C'},{id:4,label:'D'},]);var edges=new vis.DataSet([{from:1,to:2},{from:1,to:3},{from:4,to:2},{from:4,to:3}]);var data={nodes:nodes,edges:edges};if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches||document.querySelector("meta[name=darkmode]")!==null&&document.querySelector("meta[name=darkmode]").content==="true"){var options={nodes:{color:{border:'#FFFFFF',background:'#202124',highlight:{border:'#50fa7b',background:'#202124'}},font:{color:'#FFFFFF'}},interaction:{multiselect:true}}}else{var options={nodes:{color:{border:'#232333',background:'#FFFFFF',highlight:{border:'#FF0000',background:'#FFFFFF'}}},interaction:{multiselect:true}}}
var network=new vis.Network(container,data,options);</script><p>Clearly if we select two entities that share a relationship the workers will fail. Therefore, we must choose opposing entities, in this case we select the two pairs (A,D) and (B,C).</p><p>We also cannot process the pairs together, we must first process one pair and then process the other pair.</p><p>We arrive at the final solution where we have two workers instructed as follows:<br>Worker 1 - [ A, B ]<br>Worker 2 - [ D, C ]</p><p>In my view it is important to explore simple examples when exploring an issue of reasonable complexity. When exploring complex problems often there are multiple insights to be gained and viewing these insights in isolation with simple examples helps to build intuition and understanding.</p><h1 id=adjacent-entities>Adjacent Entities</h1><p>In graph theory, two vertices that share an edge are defined to be adjacent. Our constraint is now that any set of entities we processes at the same time cannot contain any adjacent entities.</p><p>Let&rsquo;s assign a colour to each group of entities that are processed, e.g first group processed is blue, second group is red and so on. We then reframe our constraint to be that if we colour all the vertices on the graph, no adjacent vertices can share the same colour (if they were they&rsquo;d be processed at the same time). To minimize the number of iterations (i.e process the entities faster) we must minimize the number of colours. This is a special case of graph labeling, a topic within graph theory, known as Graph colouring.</p><h1 id=graph-colouring>Graph Colouring</h1><p>Graph colouring is a <a href=https://en.wikipedia.org/wiki/Graph_coloring#History>famous problem</a> within maths and computer science. It can be explained quite simply as, given a graph (here&rsquo;s one for example):</p><figure><div id=colouring class=graph></div><figcaption></figcaption></figure><script type=text/javascript>var container=document.getElementById('colouring');var nodes=new vis.DataSet([{id:1,label:'A'},{id:2,label:'B'},{id:3,label:'C'},{id:4,label:'D'},{id:5,label:'E'},{id:6,label:'F'},{id:7,label:'G'},{id:8,label:'H'},{id:9,label:'I'},{id:10,label:'J'},]);var edges=new vis.DataSet([{from:1,to:2},{from:1,to:4},{from:1,to:3},{from:4,to:2},{from:4,to:3},{from:5,to:4},{from:6,to:5},{from:7,to:6},{from:7,to:8},{from:5,to:8},{from:9,to:8},{from:5,to:10},]);var data={nodes:nodes,edges:edges};if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches||document.querySelector("meta[name=darkmode]")!==null&&document.querySelector("meta[name=darkmode]").content==="true"){var options={nodes:{color:{border:'#FFFFFF',background:'#202124',highlight:{border:'#50fa7b',background:'#202124'}},font:{color:'#FFFFFF'}},interaction:{multiselect:true}}}else{var options={nodes:{color:{border:'#232333',background:'#FFFFFF',highlight:{border:'#FF0000',background:'#FFFFFF'}}},interaction:{multiselect:true}}}
var network=new vis.Network(container,data,options);</script><p>How many crayons do you need such that no circles that are connected have the same colour?</p><p>We then can reframe our initial problem to be:<br><em>Given a graph, what is the minimum set of colours I need to colour each node such that two adjacent nodes do not share the same colour?</em></p><p>Generalised solutions to it are not polynomial in execution time, and those that are polynomial in execution time constrain the input graphs they apply to.</p><h1 id=greed-is-good>Greed is good</h1><p>Let&rsquo;s implement a basic algorithm to start assigning colours to our vertices. One of the simplest is the <a href=https://en.wikipedia.org/wiki/Greedy_coloring>greedy algorithm</a>). The steps of the greedy algorithm are as follows:</p><ul><li>Iterate over every vertex<ul><li>For the current vertex get the set of colours used for its neighbours</li><li>Find the first colour that in our list of colours that is not used by any neighbours and assign it to the current vertex</li></ul></li></ul><p>In python code this would look something like (we use integers starting at 0 to denote colours):<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>colour</span>(graph):
    colours <span style=color:#f92672>=</span> {}
    <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> graph<span style=color:#f92672>.</span>keys():
        <span style=color:#75715e># Get the colours of the neighbours</span>
        used_colours <span style=color:#f92672>=</span> set(
            [colours[neighbour] <span style=color:#66d9ef>for</span> neighbour <span style=color:#f92672>in</span> graph[vertex] <span style=color:#66d9ef>if</span> neighbour <span style=color:#f92672>in</span> colours]
        )

        colour <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
        <span style=color:#66d9ef>for</span> used_colour <span style=color:#f92672>in</span> used_colours:
            <span style=color:#75715e># Find the first available colour that hasn&#39;t been used</span>
            <span style=color:#66d9ef>if</span> colour <span style=color:#f92672>!=</span> used_colour:
                <span style=color:#66d9ef>break</span>
            colour <span style=color:#f92672>=</span> colour <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
        colours[vertex] <span style=color:#f92672>=</span> colour
    <span style=color:#66d9ef>return</span> colours</code></pre></div></p><p>Greedy algorithms are locally optimised, which means that every step of the algorithm will only use local values (in this case only adjacent nodes to the current vertex). The drawbacks of this algorithm are that the solution depends on the order of the input vertices and that we will receive a sub-optimal solution as the algorithm won&rsquo;t (by definition) necessarily identify global optimizations.</p><p>The simple way to mitigate this is to run the algorithm multiple times with a random sort being applied to each iteration and select the result with the fewest colours. Given the dataset is metadata (i.e data types and relationships) scaling issues are not a concern.</p><h1 id=solution>Solution</h1><p>We&rsquo;ve identified a simple approach to solving this problem, what remains is to implement the complete algorithm.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> sys
<span style=color:#f92672>import</span> random

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>colour</span>(graph, order):
  colours <span style=color:#f92672>=</span> {}
  max_colour <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#66d9ef>for</span> vertex <span style=color:#f92672>in</span> order:
    <span style=color:#75715e># Get the colours of the neighbours</span>
    used_colours <span style=color:#f92672>=</span> set(
        [colours[neighbour] <span style=color:#66d9ef>for</span> neighbour <span style=color:#f92672>in</span> graph[vertex] <span style=color:#66d9ef>if</span> neighbour <span style=color:#f92672>in</span> colours]
    )

    colour <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#66d9ef>for</span> used_colour <span style=color:#f92672>in</span> used_colours:
        <span style=color:#75715e># Find the first available colour that hasn&#39;t been used</span>
        <span style=color:#66d9ef>if</span> colour <span style=color:#f92672>!=</span> used_colour:
            <span style=color:#66d9ef>break</span>
        colour <span style=color:#f92672>=</span> colour <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
        <span style=color:#66d9ef>if</span> colour <span style=color:#f92672>&gt;</span> max_colour:
            max_colour <span style=color:#f92672>=</span> colour
    colours[vertex] <span style=color:#f92672>=</span> colour
  <span style=color:#66d9ef>return</span> colours, max_colour

<span style=color:#75715e># Graph from second example</span>
graph <span style=color:#f92672>=</span> {
  <span style=color:#e6db74>&#34;A&#34;</span>: [<span style=color:#e6db74>&#34;B&#34;</span>, <span style=color:#e6db74>&#34;C&#34;</span>, <span style=color:#e6db74>&#34;D&#34;</span>],  
  <span style=color:#e6db74>&#34;B&#34;</span>: [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;D&#34;</span>],  
  <span style=color:#e6db74>&#34;C&#34;</span>: [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;D&#34;</span>],  
  <span style=color:#e6db74>&#34;D&#34;</span>: [<span style=color:#e6db74>&#34;A&#34;</span>, <span style=color:#e6db74>&#34;B&#34;</span>, <span style=color:#e6db74>&#34;C&#34;</span>, <span style=color:#e6db74>&#34;E&#34;</span>],    
  <span style=color:#e6db74>&#34;E&#34;</span>: [<span style=color:#e6db74>&#34;D&#34;</span>,<span style=color:#e6db74>&#34;F&#34;</span>, <span style=color:#e6db74>&#34;J&#34;</span>,<span style=color:#e6db74>&#34;H&#34;</span>],  
  <span style=color:#e6db74>&#34;F&#34;</span>: [<span style=color:#e6db74>&#34;E&#34;</span>, <span style=color:#e6db74>&#34;G&#34;</span>],   
  <span style=color:#e6db74>&#34;G&#34;</span>: [<span style=color:#e6db74>&#34;F&#34;</span>,<span style=color:#e6db74>&#34;H&#34;</span>],  
  <span style=color:#e6db74>&#34;H&#34;</span>: [<span style=color:#e6db74>&#34;E&#34;</span>,<span style=color:#e6db74>&#34;G&#34;</span>,<span style=color:#e6db74>&#34;I&#34;</span>],  
  <span style=color:#e6db74>&#34;I&#34;</span>: [<span style=color:#e6db74>&#34;H&#34;</span>], 
  <span style=color:#e6db74>&#34;J&#34;</span>: [<span style=color:#e6db74>&#34;E&#34;</span>]
}

number_iterations <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>
vertices<span style=color:#f92672>=</span> list(graph<span style=color:#f92672>.</span>keys())
best_chromatic_number <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>maxsize
best_colours <span style=color:#f92672>=</span> {}

<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(number_iterations):
  random<span style=color:#f92672>.</span>shuffle(vertices)
  vertex_colours, max_colour <span style=color:#f92672>=</span> colour(graph, vertices)
  <span style=color:#75715e># Colours are 0 indexed, so the number of colours is max colour + 1</span>
  <span style=color:#66d9ef>if</span> max_colour <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> best_chromatic_number:
      best_colours <span style=color:#f92672>=</span> vertex_colours
      best_chromatic_number <span style=color:#f92672>=</span> max_colour <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>


<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Chromatic number:&#34;</span> <span style=color:#f92672>+</span> str(best_chromatic_number))
<span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Vertex colours:&#34;</span> <span style=color:#f92672>+</span> str(best_colours))</code></pre></div><p>Running this gives us:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext>Chromatic number: 3
Vertex colours: {
    &#39;A&#39;: 2, 
    &#39;B&#39;: 1, 
    &#39;C&#39;: 1
    &#39;D&#39;: 0, 
    &#39;E&#39;: 1, 
    &#39;F&#39;: 2, 
    &#39;G&#39;: 0, 
    &#39;H&#39;: 2, 
    &#39;I&#39;: 0, 
    &#39;J&#39;: 0, 
}</code></pre></div></p><p>In this case the best_chromatic_number is number of iterations the best solution will require to complete.</p><h1 id=limitations>Limitations</h1><p>This approach some caveats however. We could construct a data model that only uses two colours like a line of vertices or a <a href=https://en.wikipedia.org/wiki/Star_(graph_theory)>star graph</a>, which this algorithm will work well on. Even with thousands of entities they will still optimally use two colours (and we will find a solution close to that with our greedy algorithm). The worst case is a complete graph, which is defined as a graph where all vertices are adjacent which means every vertex would need a different colour, which means the trivial solution (process one entity at a time) is the only solution.</p><p>Most data models will lie somewhere inbetween this, the number of colours (or groups to process) will decrease with increased similarity to a graph that only requires two colours (namely bipartite graphs).</p><h1 id=conclusion>Conclusion</h1><p>This solution lays out a general path for optimizing this set of problems (not just distributed processing). There are further optimizations that can be made, either by constraining the input graph or by providing insight to the greedy algorithm (e.g if we have a lot of vertices with only one edge, we should make sure these are coloured the same).</p><p>If we can instruct the workers to only process a subset of the relationships then the initial problem changes entirely, which may be the topic of a future blog post.</p><p>I hope you found this interesting, and it has piqued your interest in graph theory and its application to distributed systems.</p><h1 id=references>References</h1><p><a href=https://thorehusfeldt.files.wordpress.com/2010/08/gca.pdf>Graph colouring algorithms - Thore Husfeldt</a></p></section><div class=post-tags></div></article></main><footer><hr><a class=soc href=https://github.com/mackles title=Github><i data-feather=github></i></a>|<a class=soc href=https://www.linkedin.com/in/stuart-mackle-5b2055105/ title=LinkedIn><i data-feather=linkedin></i></a>|⚡️
2021 © Stuart Mackle | <a href=https://github.com/mackles/archie-network>Archie Network Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer><script>feather.replace()</script></div></body></html>